package me.paul.hw3.simulation.grid;

import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JPanel;

import me.paul.hw3.simulation.Agent;
import me.paul.hw3.simulation.Simulation;

/**
 * This is the class that will represent the grid environment for a
 * {@link Simulation} object
 * 
 * @author Paul Guarnieri
 */
public class Board extends JPanel {
	/**
	 * Generated by {@link JPanel}
	 */
	private static final long serialVersionUID = 7157079009555542796L;
	/**
	 * 2-Dimensional Array that contains all of our {@link Cell}s. Since we are
	 * using this structure, The origin (0,0), technically starts on the top right
	 * section of the graph rather than the center
	 */
	private Cell[][] cells;
	/**
	 * Number of rows on the grid
	 */
	private int rows;
	/**
	 * Number of columns on the grid
	 */
	private int columns;
	/**
	 * The {@link Simulation} that this {@link Board} belongs to
	 */
	private Simulation simulation;

	/**
	 * Constructs a new board for a {@link Simulation}
	 * 
	 * @param simulation {@link Simulation} that this {@link Board} belongs to
	 * @param rows       Number of rows that this {@link Board} is bounded to
	 * @param columns    Number of columns that this {@link Board} is bounded to
	 */
	public Board(Simulation simulation, int rows, int columns) {
		this.simulation = simulation;
		this.rows = rows;
		this.columns = columns;
		this.cells = new Cell[rows][columns];
		setLayout(new GridLayout(rows, columns));
		setOpaque(false);
		fillGrid();
	}

	/**
	 * Method that will be used to fill our grid space environment. Will only be
	 * called once in the constructor
	 */
	private void fillGrid() {
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < columns; j++) {
				Cell c = new Cell(this, i, j);
				cells[i][j] = c;
				add(c);
			}
		}
	}

	/**
	 * Check if a coordinate pair exists in this {@link Board}
	 * 
	 * @param row    Row or "x" coordinate
	 * @param column Column or "y" coordinate
	 * @return Whether or not the pair actually exists in this grid
	 */
	public boolean inBounds(int row, int column) {
		return row >= 0 && row < rows && column >= 0 && column < columns;
	}

	/**
	 * Locate a cell in the grid space environment
	 * 
	 * @param row    The row where the cell is located
	 * @param column The column where the cell is located
	 * @return The cell, if found
	 */
	public Cell findCell(int row, int column) {
		if (!inBounds(row, column))
			return null;
		return cells[row][column];
	}

	/**
	 * Find the {@link Agent} in this {@link Board} grid environment
	 * 
	 * @param <T>        Type parameter for the Type of {@link Agent} you want to
	 *                   find
	 * @param agentClazz The class that represents the specific Agent we are trying
	 *                   to find
	 * @return List of the found Agents
	 */
	public <T extends Agent<T>> List<T> getAgents(Class<T> agentClazz) {
		List<T> toReturn = new ArrayList<>();
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < columns; j++) {
				Cell c = cells[i][j];
				if (c.isOccupied() && agentClazz.isInstance(c.getOccupying()))
					toReturn.add((T) c.getOccupying());
			}
		}
		return toReturn;
	}

	/**
	 * @return List of all the {@link Agent} currently residing in the {@link Board}
	 */
	public List<Agent<?>> getAllAgents() {
		List<Agent<?>> toReturn = new ArrayList<>();
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < columns; j++) {
				Cell c = cells[i][j];
				if (c.isOccupied())
					toReturn.add(c.getOccupying());
			}
		}
		return toReturn;
	}

	/**
	 * Enumeration to represent a simple Direction in our {@link Board} grid
	 * environment as a Vector of 2 points
	 * <p>
	 * When an {@link Agent} wants to move in a {@link Direction}, it simply adds
	 * the pair of points of the given {@link Direction} to the {@link Cell} that
	 * the {@link Agent} belongs to
	 * 
	 * @author Paul Guarnieri
	 */
	public enum Direction {
		NORTH(-1, 0, "N"), NORTHEAST(-1, 1, "NE"), NORTHWEST(-1, -1, "NW"), SOUTH(1, 0, "S"), SOUTHEAST(1, 1, "SE"),
		SOUTHWEST(1, -1, "SW"), EAST(0, 1, "E"), WEST(0, -1, "W");
		/**
		 * Row offset of this {@link Direction}
		 */
		private final int rowOffset;
		/**
		 * Column offset of this {@link Direction}
		 */
		private final int columnOffset;
		/**
		 * The shorthand, or easier way of saying this {@link Direction}
		 */
		private final String shortHand;

		/**
		 * Find an instance of {@link Direction} given a pair of Vector coordinates
		 * 
		 * @param row X coordinate
		 * @param col Y coordinate
		 * @return The Directional Vector associated with that pair
		 */
		public static Direction valueOf(int row, int col) {
			for (Direction d : values()) {
				if (d.rowOffset == row && d.columnOffset == col)
					return d;
			}
			return null;
		}

		private Direction(final int rowOffset, final int columnOffset, final String shortHand) {
			this.rowOffset = rowOffset;
			this.columnOffset = columnOffset;
			this.shortHand = shortHand;
		}

		/**
		 * @return Row offset of this {@link Direction}
		 */
		public int getRowOffset() {
			return this.rowOffset;
		}

		/**
		 * @return Column offset of this {@link Direction}
		 */
		public int getColumnOffset() {
			return this.columnOffset;
		}

		/**
		 * @return The shorthand, or easier way of saying this {@link Direction}
		 */
		public String getShortHand() {
			return this.shortHand;
		}
	}

	/**
	 * @return Number of rows on the grid
	 */
	public int getRows() {
		return this.rows;
	}

	/**
	 * @return Number of columns on the grid
	 */
	public int getColumns() {
		return this.columns;
	}

	/**
	 * @return The {@link Simulation} that this {@link Board} belongs to
	 */
	public Simulation getSimulation() {
		return this.simulation;
	}
}
